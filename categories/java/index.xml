<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Brandy</title>
    <link>https://brandykk.github.io/categories/java/</link>
    <description>Recent content in java on Brandy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This is a customized copyright.</copyright>
    <lastBuildDate>Sat, 07 Aug 2021 23:03:10 +0800</lastBuildDate>
    <atom:link href="https://brandykk.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SpringBoot</title>
      <link>https://brandykk.github.io/posts/java/spring/springboot/</link>
      <pubDate>Sat, 07 Aug 2021 23:03:10 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/spring/springboot/</guid>
      <description>小彩蛋：修改springboot启动banner,也就是控制台打印的图像 在resources在创建banner.txt,然后把网上复制的banner粘贴进去
.::::. .::::::::. ::::::::::: &amp;#39;:::::::::::.. :::::::::::::::&amp;#39; &amp;#39;:::::::::::. .::::::::::::::&amp;#39; .:::::::::::... ::::::::::::::&amp;#39;&amp;#39; .:::. &amp;#39;::::::::&amp;#39;&amp;#39;:::: .::::::::. &amp;#39;:::::&amp;#39; &amp;#39;:::: .::::&amp;#39;:::::::. ::::: &amp;#39;::::. .:::::&amp;#39; &amp;#39;:::::::::. ::::: &amp;#39;:::. .:::::&amp;#39; &amp;#39;:::::::::.::::: &amp;#39;::. .::::&amp;#39;&amp;#39; &amp;#39;:::::::::::::: &amp;#39;::. .::&amp;#39;&amp;#39; &amp;#39;:::::::::::: :::... ..:::: &amp;#39;:::::::::&amp;#39; .:&amp;#39; &amp;#39;&amp;#39;&amp;#39;&amp;#39; ..&amp;#39;&amp;#39;&amp;#39;&amp;#39;&amp;#39;:&amp;#39; &amp;#39;:::::.&amp;#39; 1. springboot依赖 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.3&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;com.bin&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springboot&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;springboot&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.</description>
    </item>
    <item>
      <title>SpringMVC</title>
      <link>https://brandykk.github.io/posts/java/spring/springmvc/</link>
      <pubDate>Sat, 07 Aug 2021 21:09:25 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/spring/springmvc/</guid>
      <description>SpringMVC MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。
Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） - 视图代表模型包含的数据的可视化。 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 MVC的优点：
1.耦合性低
视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。
2.重用性高
MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型，它包括任何WEB（HTTP）浏览器或者无线浏览器（wap），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。
3.部署快，生命周期成本低
MVC使开发和维护用户接口的技术含量降低。使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。
4.可维护性高
分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。
MVC的缺点：
1.完全理解MVC比较复杂。
由于MVC模式提出的时间不长，加上同学们的实践经验不足，所以完全理解并掌握MVC不是一个很容易的过程。
2.调试困难。
因为模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难，每个构件在使用之前都需要经过彻底的测试。
3.不适合小型，中等规模的应用程序
在一个中小型的应用程序中，强制性的使用MVC进行开发，往往会花费大量时间，并且不能体现MVC的优势，同时会使开发变得繁琐。
4.增加系统结构和实现的复杂性
对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。
5.视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问
视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。
依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。
SpringMVC工作原理 理论 SpringMVC工作原理： 客户端发起请求（http）通过web.xml找到 DispatchServlet（前端控制器）； 由DispatchServlet控制器通过配置文件（servletName-servlet.xml）寻找到一个或多个HandlerMapping（映射处理器），找到用于处理请求的controller（后端控制器）； DispatchServlet将请求提交到controller； Controller处理业务逻辑后， controller返回数据 ModelAndVIew给DispatchServlet； DispatchServlet寻找到一个或多个ViewResolver（视图解析器），找到ModelAndVIew指定的视图； DispatchServle负责将结果返给View（客户端JSP页面），封装Http； view响应页面的HTTP请求，返回响应数据，浏览器绘制页面。 补充：
第2~3步，里面隐藏了步骤： DispatchServlet 根据 HandlerMapping（专门映射处理器的一个映射器）的配置（用户自己配置的配置文件）找到Handler（处理器），然后由具体的HandlerAdapter处理器对Handler进行处理。
handler跟controller有啥区别？ controller 是 handler，但是handler不是controller。
handler接管所有的DispatchServlet给与的处理信息，包括静态请求（http://……/style.css），并且可以改变请求所指向的资源参数如 String target参数。
controller只做三件事接收参数、调用业务、使用业务结果渲染页面。
SpringMVC接口解释
（1）DispatcherServlet接口： Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。 （2）HandlerMapping接口： 能够完成客户请求到Controller映射。 （3）Controller接口： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 （4）ViewResolver接口： Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。 4.</description>
    </item>
    <item>
      <title>Jdbc</title>
      <link>https://brandykk.github.io/posts/java/jdbc/</link>
      <pubDate>Thu, 05 Aug 2021 22:01:35 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/jdbc/</guid>
      <description>JDBC程序 private static void jdbcUtil() throws ClassNotFoundException, SQLException { //1. 加载驱动 Class.forName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); //2.用户信息和url /** * useUnicode=true 使用unicode编码,支持中文 * characterEncoding=utf8 设置字符集为UTF-8 * useSSL=true 使用SSL安全连接 */ String url = &amp;#34;jdbc:mysql://localhost:3306/lvxiaobin?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=true&amp;#34;; String username = &amp;#34;lv&amp;#34;; String password = &amp;#34;xiao&amp;#34;; //3.接连成功,获取数据库对象 Connection connection = DriverManager.getConnection(url, username, password); //4.执行sql的对象 Statement statement = connection.createStatement(); //5.执行sql String sql = &amp;#34;select * from user&amp;#34;; //返回的结果集 ResultSet resultSet = statement.executeQuery(sql); while (resultSet.next()) { System.out.println(resultSet.getString(&amp;#34;id&amp;#34;)); } //6.释放连接 resultSet.close(); statement.close(); connection.close(); } </description>
    </item>
    <item>
      <title>Spring重点</title>
      <link>https://brandykk.github.io/posts/java/spring/spring%E8%A6%81%E7%82%B9/</link>
      <pubDate>Wed, 28 Jul 2021 21:54:52 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/spring/spring%E8%A6%81%E7%82%B9/</guid>
      <description>1. IOC理论推导 1.1. 原来的写法 1.1.1 UserDao接口 public interface UserDao { void getUser(); } 1.1.2 UserDaoImpl实现类 public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(&amp;#34;默认获取用户数据&amp;#34;); } } 1.1.3 UserService业务接口 public interface IUserService { void getUser(); } 1.1.4 UserServiceImpl业务实现类 public class UserServiceImpl implements IUserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 1.1.5 UserTest测试 public class UserTest { public static void main(String[] args) { //用户实际调用的业务层，Dao层不会直接调用 IUserService userService = new UserServiceImpl(); userService.</description>
    </item>
    <item>
      <title>Java中常用工具类</title>
      <link>https://brandykk.github.io/posts/java/java%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Tue, 20 Jul 2021 21:53:26 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/java%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>java自带的方法 List集合拼接成以逗号分隔的字符串 //将list转为字符串 List&amp;lt;String&amp;gt; strings = Arrays.asList(&amp;#34;a,b,c,d&amp;#34;); //List&amp;lt;String&amp;gt; strings = Collections.singletonList(&amp;#34;a,b,c,d&amp;#34;); System.out.println(strings);//[a,b,c,d] //第一种方法: stream流 String collect = strings.stream().collect(Collectors.joining(&amp;#34;,&amp;#34;)); System.out.println(collect);//a,b,c,d //第二种方法: String自己的join方法 String join = String.join(&amp;#34;,&amp;#34;, strings); System.out.println(join);//a,b,c,d 比较字符串是否相等,忽略大小写 if (strA.equalsIgnoreCase(strB)) { System.out.println(&amp;#34;相等&amp;#34;); } 比较两个对象 当我们用equals比较两个对象是否相等的时候，还需要对左边的对象进行判空，不然可能会报空指针异常，我们可以用java.util包下Objects封装好的比较是否相等的方法
Objects.equals(strA, strB); 源码是这样的
public static boolean equals(Object a, Object b) { return (a == b) || (a != null &amp;amp;&amp;amp; a.equals(b)); } 两个List集合取交集 必须是ArrayList
List&amp;lt;String&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;(); list1.add(&amp;#34;a&amp;#34;); list1.add(&amp;#34;b&amp;#34;); list1.add(&amp;#34;c&amp;#34;); List&amp;lt;String&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;(); list2.</description>
    </item>
    <item>
      <title>Java中的线程</title>
      <link>https://brandykk.github.io/posts/java/java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 19 Jul 2021 22:04:34 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</guid>
      <description>创建线程的方法 继承Thread类,重写run()方法,调用start()方法开启 实现Runnable,重写run()方法,调用start()方法开启 通过Callable和FutureTask创建线程 通过线程池创建线程 继承Thread类 线程开启后不一定立即执行,由CPU调度执行
public class ThreadRun { public static void main(String[] args) { //开启线程 ThreadDemoOne threadDemoOne = new ThreadDemoOne(); threadDemoOne.start(); for (int i = 0; i &amp;lt; 5000; i++) { System.out.printf(&amp;#34;普通代码: %d%n&amp;#34;, i); } } } /** *	继承Thread类的方法,并重run() **/ class ThreadDemoOne extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 5000; i++) { System.out.println(&amp;#34;线程在这里!!&amp;#34;); } } } 执行结果
线程在这里!! 普通代码: 694 普通代码: 695 线程在这里!</description>
    </item>
    <item>
      <title>Java枚举使用</title>
      <link>https://brandykk.github.io/posts/java/java%E6%9E%9A%E4%B8%BE%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 08 Jul 2021 21:25:54 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/java%E6%9E%9A%E4%B8%BE%E4%BD%BF%E7%94%A8/</guid>
      <description>实现接口,相当于简单的抽象工厂 接口方法 //接口方法 interface EnumInterface{ void show(); } 枚举 //实现接口并重写方法 enum Enumenum implements EnumInterface{ AAA(1){ @Override public void show() { System.out.println(&amp;#34;AAA&amp;#34;); } }, BBB(2){ @Override public void show() { System.out.println(&amp;#34;BBB&amp;#34;); } } ; private int i; //通过i调用show() static void getEnumbyI(int a){ Arrays.stream(Enumenum.values()).filter(item-&amp;gt;item.getI() == a).findFirst().get().show(); } //构造方法 Enumenum(int i) { this.i = i; } public int getI() { return i; } } 测试 /** * 枚举的使用 */ public class EnumApplication { public static void main(String[] args) { getEnumByI(); } //通过值获取枚举的方法 private static void getEnumByI(){ try { Enumenum.</description>
    </item>
    <item>
      <title>Spring定时器依赖注入</title>
      <link>https://brandykk.github.io/posts/java/spring/spring%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Sun, 18 Apr 2021 16:09:32 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/spring/spring%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</guid>
      <description> 工具类 /** * 创建工具类 **/ public class ApplicationContextUtil implements ApplicationContextAware { private static ApplicationContext applicationContext; public static ApplicationContext getApplicationContext() { return applicationContext; } public void setApplicationContext(ApplicationContext applicationContext) { ApplicationContextUtil.applicationContext = applicationContext; } public static Object getBean(String beanName) { return applicationContext.getBean(beanName); } } 配置bean &amp;lt;bean id =&amp;#34;applicationContextUtil&amp;#34; class =&amp;#34;org.sihai.soil.util.ApplicationContextUtil&amp;#34; &amp;gt;&amp;lt;/bean &amp;gt; 获取service realmEbi = (RealmEbi) ApplicationContextUtil.getBean(&amp;#34;realmEbi&amp;#34;); realmEbi.insertHour(RealmApplianceModel.sendData3); </description>
    </item>
    <item>
      <title>Java树结构递归封装</title>
      <link>https://brandykk.github.io/posts/java/java%E6%A0%91%E7%BB%93%E6%9E%84%E9%80%92%E5%BD%92%E5%B0%81%E8%A3%85/</link>
      <pubDate>Sun, 18 Apr 2021 12:07:25 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/java%E6%A0%91%E7%BB%93%E6%9E%84%E9%80%92%E5%BD%92%E5%B0%81%E8%A3%85/</guid>
      <description>import java.util.ArrayList; import java.util.Comparator; import java.util.List; public class text { public static void main(String[] args) { //测试方法 Node n1 = new Node(&amp;#34;0&amp;#34;, &amp;#34;根节点&amp;#34;, &amp;#34;-1&amp;#34;, 0); Node n2 = new Node(&amp;#34;01&amp;#34;, &amp;#34;一级子节点&amp;#34;, &amp;#34;0&amp;#34;, 0); Node n3 = new Node(&amp;#34;011&amp;#34;, &amp;#34;二级子节点1&amp;#34;, &amp;#34;01&amp;#34;, 3); Node n4 = new Node(&amp;#34;012&amp;#34;, &amp;#34;二级子节点2&amp;#34;, &amp;#34;01&amp;#34;, 2); Node n5 = new Node(&amp;#34;013&amp;#34;, &amp;#34;二级子节点3&amp;#34;, &amp;#34;01&amp;#34;, 1); Node n6 = new Node(&amp;#34;0131&amp;#34;, &amp;#34;三级子节点1&amp;#34;, &amp;#34;013&amp;#34;, 1); Node n7 = new Node(&amp;#34;0132&amp;#34;, &amp;#34;三级子节点2&amp;#34;, &amp;#34;013&amp;#34;, 1); List&amp;lt;Node&amp;gt; nodeList = new ArrayList(); nodeList.</description>
    </item>
  </channel>
</rss>
