<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Win开发工具安装</title><url>/post/win/win%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/</url><categories><category>WIN</category></categories><tags><tag>工具</tag></tags><content type="html"> 安装JDK 新建系统变量
变量名： JAVA_HOME 变量值：安装目录 新建CLASSPATH变量
变量名： CLASSPATH 变量值： .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 添加Path：
在系统变量区域，选择Path,点击下面的编辑按钮，在弹出的框中选择新建添加2行，一行输入 %JAVA_HOME%\bin ，一行输入 %JAVA_HOME%\jre\bin
在命令提示符中输入javac命令测试
MAVEN配置 新建系统变量
变量名： MAVEN_HOME 变量值：安装目录 添加Path：
在系统变量区域，选择Path,点击下面的编辑按钮，在弹出的框中选择新建添加 %MAVEN_HOME%\bin
在命令提示符中输入 mvn -v 命令
安装mariadb代替mysql 下载 mariadb压缩包
配置mariadb环境变量
在path中添加mariadb安装文件夹中的bin目录下
在bin目录下执行命令
注意安装实际情况更改路径和密码
mysql_install_db.exe --datadir=F:\projectManager\mariadbData --service=mariadb --password= --port=13306 # --datadir=后面是数据存放路径，可自定义；--service=后面是服务名称；--password=后面是密码，空就是没有密码；--port=后面是端口号，为了防止和mysql用了13306 mysql安装 推荐mariadb 安装目录下新建 my.ini 文件（注意修改下面的路径）
[Client] #设置3306端口 port = 3306 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=D:\MySQL5.7\mysql-5.7.27-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\MySQL5.7\mysql-5.7.27-winx64\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # …</content></entry><entry><title>Linux子系统</title><url>/post/win/linux%E5%AD%90%E7%B3%BB%E7%BB%9F/</url><categories><category>WIN</category></categories><tags><tag>子系统</tag></tags><content type="html"><![CDATA[  在win11上安装archlinux子系统 需要先开启linux子系统和虚拟平台服务, 参考 1. 下载linux内核升级包 双击安装即可 2. 将WSL2设置为默认版本 # 管理员输入命令 wsl --set-default-version 2 3. 安装LxRunOffline 默认会安装在C盘，用这个工具可以指定安装路径
github下载 解压，里面的exe不需要安装，可以将exe路径配置环境变量方便使用，或者在exe所在的文件夹下打开控制台使用命令
4. 下载ArchLinux 下载tar.gz版本(清华源) ，也可以在官网找
5. 安装到WSL # LxRunOffline i -n &lt;自定义名称&gt; -f &lt;Arch镜像位置&gt; -d &lt;安装系统的位置&gt; -r root.x86_64 LxRunOffline i -n archlinux -f D:\WSL\archlinux_img\archlinux-bootstrap-2021.10.01-x86_64.tar.gz -d D:\WSL\archlinux -r root.x86_64 6. 进入系统 # wsl -d &lt;名字&gt; wsl -d archlinux 如果此处报：FATAL: kernel too old
输入一下命令，进行转行
# 命令格式： # wsl --set-version &lt;名称&gt; 2 # 如： wsl --set-version archlinux 2 7. 首次进入系统执行命令 pacman -Syy pacman-key --init pacman-key --populate 8. 移除linux # 查看已安装的系统 wsl -l -v # 卸载 wsl --unregister 名字 9. 创建新用户 useradd -m -G wheel -s /bin/bash &lt;用户名&gt; # 将文件/etc/sudoers中的wheel ALL=(ALL) ALL那一行前面的注释去掉 # 查看当前用户id id -u &lt;用户名&gt; # 退出linux lxrunoffline su -n &lt;你的arch名字&gt; -v &lt;账户id&gt; 10. 导入导出镜像 # 导出 wsl --export Arch F:\Arch.tar #导入 wsl --import Arch d:\Arch F:\Arch.tar --version 2 11. 重启WSL wsl --shutdown 12. 开启systemctl和默认用户 vim /etc/wsl.conf [boot] systemd=true [user] default=用户名 13.mariadb开机自启 wsl2启动mariadb时无法创建mysql文件夹，需要手动创建
# 编写脚本 mariadb.local 文件 # mkdir /run/mysql &amp; chown -R mysql:mysql /run/mysql &amp; systemctl start mariadb.service chmod +x ~/mariadb.local # vim /usr/lib/systemd/system/mariadb-local.service [Unit] Description=&#34;mariadb databases start servece&#34; [Service] Type=forking ExecStart=/root/mariadb.local start TimeoutSec=0 StandardInput=tty RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target # systemctl enable mariadb-local.service   ]]></content></entry><entry><title>服务器证书生成说明</title><url>/post/linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E8%AF%B4%E6%98%8E/</url><categories><category>Linux</category></categories><tags><tag>证书</tag></tags><content type="html"> 此文档使用的系统: WSL2-ArchLinux 进行的以下操作：建议用root账号进行操作，并在统一目录下操作。
生成CA证书 生成CA私钥 openssl genrsa -des3 -out ca.key 2048 此命令应该会要求你输入一个ca.key对应的加密密码（可以输入个123456方便记）。输入后密码需要记下来后面还要用。
生成不加密的CA私钥 openssl genrsa -out ca_decrypted.key 2048 生成CA公钥即CA根证书 openssl req -new -x509 -days 3650 -key ca.key -out ca.crt 输入命令后应该会需要你输入一些证书相关的周边信息。比如证书颁发机构所在地址，机构名称等等。，唯一需要注意的是Common Name那一栏。为了后面操作顺利，建议将这里填写主机名或者主机IP。
生成HTTPS证书的准备 创建ssl.cnf文件并写入内容
authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment subjectAltName = @alt_names [alt_names] DNS.1= localhost DNS.2= localhost.loacl IP.1 = 192.168.1.1 IP.2 = 192.168.1.2 其中IP.*项看自己需要写自己的ip，可以写多个。
生成HTTPS证书 生成HTTPS证书私钥 openssl genrsa -des3 -out xxxx.pem 1024 这里的xxxx指的就是上面说的主机名或者主机IP，下面的同理
生成不加密的https主机证书私钥 openssl rsa -in xxxx.pem -out xxxx.key 生成签名请求 openssl req -new -key xxxx.pem -out xxxx.csr 注意ssl.cnf的路径和上面自己创建的路径保持一致　其中，policy参数允许签名的CA和网站证书可以有不同的国家、地名等信息，days参数则是签名时限。唯一需要注意的是Common …</content></entry><entry><title>ArchLinux安装</title><url>/post/linux/archlinux%E5%AE%89%E8%A3%85/</url><categories><category>Linux</category></categories><tags><tag>Arch</tag></tags><content type="html"> 更新于2023年3月7日；适用于Arch和win11双系统，btrfs文件系统，kde桌面
准备工作 先安装win10,然后再安装linux,关闭主板设置中的 Secure Boot,关闭win10的快速启动
制作镜像：推荐 ventoy 确保是否为 UEFI 模式
# 若输出了一堆东西，即` efi `变量，则说明已在 `UEFI `模式。否则请确认你的启动方式是否为 `UEFI`。 ls /sys/firmware/efi/efivars 分区( Btrfs ) Btrfs 文件系统不需要单独区分每个盘的大小，只需要单独分出一个盘即可。
单系统需要先将磁盘转为gpt格式，双系统的话，在win11上已经转过了，/dev/nvme0n1p6是安装磁盘，根据实际情况改成自己的磁盘 # 如果需要转gpt则执行命令 lsblk #显示分区情况 parted /dev/sdx #执行parted，进行磁盘类型变更 (parted)mktable #输入mktable New disk label type? gpt #输入gpt 将磁盘类型转换为gpt 如磁盘有数据会警告，输入yes即可 quit #最后quit退出parted命令行交互 # 或 # 如果是单个磁盘，不需要要保留磁盘数据则执行以下命令可以直接选择将磁盘转为`gpt`（不会读取硬盘已有分区） # cfdisk -z /dev/nvme0n1p6 # 不需要转gpt,在已有分区基础上继续分区（会读取硬盘已有分区） cfdisk /dev/nvme0n1 # 格式化磁盘 mkfs.btrfs -f /dev/nvme0n1p6 创建子卷 # 挂在分区 mount /dev/nvme0n1p6 /mnt # 根据需要在/mnt中创建子卷 btrfs su cr /mnt/@ # 挂载到 root，必需 btrfs su cr /mnt/@boot # boot 子卷, 可选 btrfs su cr /mnt/@home # home ，可选 btrfs su cr /mnt/@var # var, 可选 btrfs su cr /mnt/@opt # opt, 可选 btrfs su cr /mnt/@snapshot # 快照文件, 可选 btrfs su cr /mnt/@swap # swapfile ，可 …</content></entry><entry><title>docker</title><url>/post/%E7%BC%96%E7%A8%8B/tool/docker/</url><categories><category>编程</category></categories><tags><tag>docker</tag></tags><content type="html"><![CDATA[  Docker下载 # archlinux sudo pacman -Syu docker docker-compose # 将用户lv追加进docker用户组 # 将当前用户添加进docker用户组 -a append; -G group sudo usermod -a -G docker lv Docker运行 # 修改docker默认镜像安装路径(没有则新建) vim /etc/docker/daemon.json # 修改文件中的路径 { &#34;registry-mirrors&#34;: [ &#34;https://registry.cn-hangzhou.aliyuncs.com&#34;, &#34;https://hub-mirror.c.163.com&#34; ] } # 重新加载配置文件 systemctl daemon-reload # 启动docker服务 systemctl start/stop docker.service Docker基础使用 # 下载镜像 docker pull mariadb # 查看镜像 docker images # 启动/停止容器 docker start/stop &lt;容器ID或容器名&gt; # 删除镜像之前需要先删除对应的容器 # 查看容器 docker ps -a # 删除容器 docker rm 容器id # 删除image docker rmi 镜像id Docker-Compose # 创建yml配置文件 mkdir ~/docker touch docker-compose.yml # 进入docker-compose.yml同级下的目录内使用docker-compose # 查看镜像 docker-compose images # 待yml配置好后执行命令创建容器 # -d 后台执行 docker-compose up -d # 查看所有服务 docker-compose ps -a # 启动/停止服务 docker-compose start/stop 服务名 #查看已启动的服务 docker-compose ps #查看所有的服务 docker-compose ps -a # 删除服务（删除之前需要停止服务） docker-compose rm 服务名称 docker-compose.yml示例
version: &#34;3.0&#34; # docker-compose版本 # 服务配置 services: docker-mariadb: # 服务名称 image: mariadb # 镜像名称或镜像id restart: always container_name: docker-mariadb # 容器名称 logging: options: max-size: &#34;500m&#34; ports: # 端口映射： 外部端口:容器内端口 - 13306:3306 volumes: # 文件映射： 外部文件:容器内文件 - /home/lv/docker/mariadb/data:/var/lib/mysql - /home/lv/docker/mariadb/logs:/logs - /home/lv/docker/mariadb/conf:/etc/mysql/conf.d environment: # 环境配置 MYSQL_ROOT_PASSWORD: root # 数据库root账号的密码 TZ: Asia/Shanghai networks: - lv_hosts networks: lv_hosts: redis # 创建映射目录 mkdir -p /mnt/project/archLinux/docker/redis/{data,etc} # 拉取redis镜像 docker pull redis # 创建redis.conf放入创建好的etc文件夹下 # 创建容器 docker run --name docker-redis -p 16379:6379 -v /mnt/project/archLinux/docker/redis/data/:/data -v /mnt/project/archLinux/docker/redis/etc/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf --appendonly yes -p 16380:6380 端口映射：前表示主机部分，：后表示 容器 部分。 –name myredis 指定该容器名称，查看和进行操作都比较方便。 -v 挂载目录，规则与端口映射相同。 -d redis 表示后台启动redis redis-server /etc/redis/redis.conf 以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/usr/local/ docker /redis.conf appendonly yes 开启redis 持久化   ]]></content></entry><entry><title>git基础</title><url>/post/%E7%BC%96%E7%A8%8B/tool/git%E5%9F%BA%E7%A1%80/</url><categories><category>编程</category></categories><tags><tag>git</tag></tags><content type="html"><![CDATA[  git命令 # 全局设置提交代码的联系邮箱 git config --global user.email &#34;mescal1993@hotmail.com&#34; # 全局设置提交代码的显示名称 git config --global user.name &#34;lv&#34; # 解决每次提交代码都要输入帐号密码： 执行命令，然后在输入一次就好了 git config --global credential.helper store #初始化本地新的git仓库 git init #克隆github仓库 git clone 地址 #查看状态 git status # .：代表添加所有文件 git add . # 提交到本地仓库 git commit -m &#39;update&#39; # 推送到服务器 git push # 从服务器拉取 git pull # fatal: refusing to merge unrelated histories错误是两个仓库合并导致历史记录不一样导致的 git pull origin master --allow-unrelated-histories --rebase 配置gitee.io 安装hugo	中文文档 sudo pacman -Sy hugo # 在代码根目录 # 创建新模板 hugo new ./content/posts/fire.md # 启动服务 hugo server # 打包 在项目根目录下打包，public目录中 hugo 主题 github 我的地址 github令牌 先申请token令牌
# 移除远程连接 git remote remove origin # 将令牌添加在地址前面用@符号区分 git remote add origin https://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@github.com/brandykk/brandykk.github.io.git # 关联main分支 git push --set-upstream origin main   ]]></content></entry><entry><title>Java递归</title><url>/post/%E7%BC%96%E7%A8%8B/java/java%E6%A0%91%E7%BB%93%E6%9E%84%E9%80%92%E5%BD%92%E5%B0%81%E8%A3%85/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[   import java.util.ArrayList; import java.util.Comparator; import java.util.List; public class text { public static void main(String[] args) { //测试方法 Node n1 = new Node(&#34;0&#34;, &#34;根节点&#34;, &#34;-1&#34;, 0); Node n2 = new Node(&#34;01&#34;, &#34;一级子节点&#34;, &#34;0&#34;, 0); Node n3 = new Node(&#34;011&#34;, &#34;二级子节点1&#34;, &#34;01&#34;, 3); Node n4 = new Node(&#34;012&#34;, &#34;二级子节点2&#34;, &#34;01&#34;, 2); Node n5 = new Node(&#34;013&#34;, &#34;二级子节点3&#34;, &#34;01&#34;, 1); Node n6 = new Node(&#34;0131&#34;, &#34;三级子节点1&#34;, &#34;013&#34;, 1); Node n7 = new Node(&#34;0132&#34;, &#34;三级子节点2&#34;, &#34;013&#34;, 1); List&lt;Node&gt; nodeList = new ArrayList(); nodeList.add(n1); nodeList.add(n2); nodeList.add(n3); nodeList.add(n4); nodeList.add(n5); nodeList.add(n6); nodeList.add(n7); nodeList = getInfiniteLevelTree(nodeList); System.out.println( getInfiniteLevelTree(nodeList)); } // 入口方法 public static List&lt;Node&gt; getInfiniteLevelTree(List&lt;Node&gt; nodeList) { List&lt;Node&gt; list = new ArrayList&lt;&gt;(); // 遍历节点列表 for (Node node : nodeList) { if (node.getParentId().equals(&#34;-1&#34;)) { // parentID为-1（根节点）作为入口 node.setChildren(getChildrenNode(node.getId(), nodeList)); list.add(node); } } // 排序 list.sort(new NodeOrderComparator()); return list; } // 获取子节点的递归方法 public static List&lt;Node&gt; getChildrenNode(String id, List&lt;Node&gt; nodeList) { List&lt;Node&gt; lists = new ArrayList&lt;&gt;(); for (Node node : nodeList) { if (node.getParentId().equals(id)) { // 递归获取子节点 node.setChildren(getChildrenNode(node.getId(), nodeList)); lists.add(node); } } // 排序 lists.sort(new NodeOrderComparator()); return lists; } } // 节点Bean class Node { private String id; private String name; private String parentId; private int order; private List&lt;Node&gt; children = new ArrayList&lt;&gt;(); public Node(String id, String name, String parentId, int order) { super(); this.id = id; this.name = name; this.parentId = parentId; this.order = order; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getParentId() { return parentId; } public void setParentId(String parentId) { this.parentId = parentId; } public int getOrder() { return order; } public void setOrder(int order) { this.order = order; } public List&lt;Node&gt; getChildren() { return children; } public void setChildren(List&lt;Node&gt; children) { this.children = children; } @Override public String toString() { return &#34;Node [id=&#34; + id + &#34;, name=&#34; + name + &#34;, parentId=&#34; + parentId + &#34;, order=&#34; + order + &#34;, children=&#34; + children + &#34;]&#34;; } } // 节点排序Comparator class NodeOrderComparator implements Comparator&lt;Node&gt;{ // 按照节点排序值进行排序 public int compare(Node n1, Node n2) { return (n1.getOrder() &lt; n2.getOrder() ? -1 : (n1.getOrder() == n2.getOrder() ? 0 : 1)); } }   ]]></content></entry><entry><title>Java工具类</title><url>/post/%E7%BC%96%E7%A8%8B/java/java%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  java自带的方法 List集合拼接成以逗号分隔的字符串 //将list转为字符串 List&lt;String&gt; strings = Arrays.asList(&#34;a,b,c,d&#34;); //List&lt;String&gt; strings = Collections.singletonList(&#34;a,b,c,d&#34;); System.out.println(strings);//[a,b,c,d] //第一种方法: stream流 String collect = strings.stream().collect(Collectors.joining(&#34;,&#34;)); System.out.println(collect);//a,b,c,d //第二种方法: String自己的join方法 String join = String.join(&#34;,&#34;, strings); System.out.println(join);//a,b,c,d 比较字符串是否相等,忽略大小写 if (strA.equalsIgnoreCase(strB)) { System.out.println(&#34;相等&#34;); } 比较两个对象 当我们用equals比较两个对象是否相等的时候，还需要对左边的对象进行判空，不然可能会报空指针异常，我们可以用java.util包下Objects封装好的比较是否相等的方法
Objects.equals(strA, strB); 源码是这样的
public static boolean equals(Object a, Object b) { return (a == b) || (a != null &amp;&amp; a.equals(b)); } 两个List集合取交集 必须是ArrayList
List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); list1.add(&#34;a&#34;); list1.add(&#34;b&#34;); list1.add(&#34;c&#34;); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); list2.add(&#34;a&#34;); list2.add(&#34;b&#34;); list2.add(&#34;d&#34;); list1.retainAll(list2); System.out.println(list1); // 输出[a, b] apache commons工具类库 apache commons是最强大的，也是使用最广泛的工具类库，里面的子库非常多，下面介绍几个最常用的
commons-lang，java.lang的增强版 建议使用commons-lang3，优化了一些api，原来的commons-lang已停止更新
&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt; &lt;/dependency&gt; 首字母转成大写 String str = &#34;yideng&#34;; String capitalize = StringUtils.capitalize(str); System.out.println(capitalize); // 输出Yideng 重复拼接字符串 // Date类型转String类型 String date = DateFormatUtils.format(new Date(), &#34;yyyy-MM-dd HH:mm:ss&#34;); System.out.println(date); // 输出 2021-05-01 01:01:01 // String类型转Date类型 Date date = DateUtils.parseDate(&#34;2021-05-01 01:01:01&#34;, &#34;yyyy-MM-dd HH:mm:ss&#34;); // 计算一个小时后的日期 Date date = DateUtils.addHours(new Date(), 1); 包装临时对象 当一个方法需要返回两个及以上字段时，我们一般会封装成一个临时对象返回，现在有了Pair和Triple就不需要了
// 返回两个字段 ImmutablePair&lt;Integer, String&gt; pair = ImmutablePair.of(1, &#34;yideng&#34;); System.out.println(pair.getLeft() + &#34;,&#34; + pair.getRight()); // 输出 1,yideng // 返回三个字段 ImmutableTriple&lt;Integer, String, Date&gt; triple = ImmutableTriple.of(1, &#34;yideng&#34;, new Date()); System.out.println(triple.getLeft() + &#34;,&#34; + triple.getMiddle() + &#34;,&#34; + triple.getRight()); // 输出 1,yideng,Wed Apr 07 23:30:00 CST 2021 commons-collections 集合工具类 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.4&lt;/version&gt; &lt;/dependency&gt; 集合取交集 // 两个集合取交集 Collection&lt;String&gt; collection = CollectionUtils.retainAll(listA, listB); // 两个集合取并集 Collection&lt;String&gt; collection = CollectionUtils.union(listA, listB); // 两个集合取差集 Collection&lt;String&gt; collection = CollectionUtils.subtract(listA, listB); common-beanutils 操作对象 &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; 对象和map互转 // 对象转map Map&lt;String, String&gt; map = BeanUtils.describe(user); System.out.println(map); // 输出 {&#34;id&#34;:&#34;1&#34;,&#34;name&#34;:&#34;yideng&#34;} // map转对象 User newUser = new User(); BeanUtils.populate(newUser, map); System.out.println(newUser); // 输出 {&#34;id&#34;:1,&#34;name&#34;:&#34;yideng&#34;} commons-io 文件流处理 &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; 文件处理 File file = new File(&#34;demo1.txt&#34;); // 读取文件 List&lt;String&gt; lines = FileUtils.readLines(file, Charset.defaultCharset()); // 写入文件 FileUtils.writeLines(new File(&#34;demo2.txt&#34;), lines); // 复制文件 FileUtils.copyFile(srcFile, destFile);   ]]></content></entry><entry><title>Java基础</title><url>/post/%E7%BC%96%E7%A8%8B/java/java%E5%9F%BA%E7%A1%80/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  获取当前日期 LocalDate date = LocalDate.now(); System.out.println(&amp;#34;获取当前日期：&amp;#34; + date); 获取当前日期：2020-12-23 LocalDate.of(int year, int month, int dayOfMonth) 该方法的月份从1开始 LocalDate date = LocalDate.of(2020, 1, 31); System.out.println(&amp;#34;输出时间：&amp;#34; + date); 输出时间：2020-01-31 时间计算 LocalDate date = LocalDate.of(2020, 1, 31); // 加一天，也可以使用负数-1实现减一天 LocalDate date1 = date.plusDays(1); // 加月份 LocalDate date2 = date.plusMonths(1); // 减 LocalDate date3 = date.minusDays(1); System.out.println(&amp;#34;输出时间：&amp;#34; + date); System.out.println(&amp;#34;date加1天：&amp;#34; + date1); System.out.println(&amp;#34;date加1月：&amp;#34; + date2); System.out.println(&amp;#34;date减1天：&amp;#34; + date3); 输出时间：2020-01-31 date加1天：2020-02-01 date加1月：2020-02-29 date减1天：2020-01-30 格式化 1. 字符串、时间转换 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); // 日期时间转字符串 LocalDateTime now = LocalDateTime.now(); String nowText = now.format(formatter); System.out.println(&amp;#34;日期转字符串：&amp;#34; + nowText); // 字符串转日期时间 String …  ]]></content></entry><entry><title>Java集合</title><url>/post/%E7%BC%96%E7%A8%8B/java/java%E4%B8%ADlist-map%E6%8E%92%E5%BA%8F/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  //通过key排序 private static void sort1() { //List&lt;Map&lt;String,Object&gt;&gt;根据map的key值排序 List&lt;Map&lt;String,Object&gt;&gt; list = new ArrayList&lt;&gt;(); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&#34;a&#34;,&#34;1&#34;); Map&lt;String,Object&gt; map1 = new HashMap&lt;&gt;(); map1.put(&#34;a&#34;,&#34;6&#34;); Map&lt;String,Object&gt; map2 = new HashMap&lt;&gt;(); map2.put(&#34;a&#34;,&#34;3&#34;); Map&lt;String,Object&gt; map3 = new HashMap&lt;&gt;(); map3.put(&#34;a&#34;,&#34;5&#34;); Map&lt;String,Object&gt; map4 = new HashMap&lt;&gt;(); map4.put(&#34;a&#34;,&#34;4&#34;); Map&lt;String,Object&gt; map5 = new HashMap&lt;&gt;(); map5.put(&#34;a&#34;,&#34;2&#34;); list.add(map); list.add(map1); list.add(map2); list.add(map3); list.add(map4); list.add(map5); //重写map的排序方式 Comparator&lt;Map&lt;String,Object&gt;&gt; co = new Comparator&lt;Map&lt;String, Object&gt;&gt;() { @Override public int compare(Map&lt;String, Object&gt; o1, Map&lt;String, Object&gt; o2) { return String.valueOf(o1.get(&#34;a&#34;)).compareTo(String.valueOf(o2.get(&#34;a&#34;))); } }; //lambda方式 Comparator&lt;Map&lt;String,Object&gt;&gt; co1 = (o1,o2)-&gt;String.valueOf(o1.get(&#34;a&#34;)).compareTo(String.valueOf(o2.get(&#34;a&#34;))); //Comparator.comparing() Comparator&lt;Map&lt;String,Object&gt;&gt; co2 = Comparator.comparing(o -&gt; String.valueOf(o.get(&#34;a&#34;))); //调用排序 list.sort(co); // list.sort(co.reversed()); // Collections.sort(list,co); System.out.println(list); } //根据value排序 private static void sort2(){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&#34;a&#34;,&#34;1&#34;); map.put(&#34;b&#34;,&#34;3&#34;); map.put(&#34;c&#34;,&#34;5&#34;); map.put(&#34;d&#34;,&#34;2&#34;); map.put(&#34;e&#34;,&#34;4&#34;); //用Map.Entry Comparator&lt;Map.Entry&lt;String,Object&gt;&gt; co = new Comparator&lt;Map.Entry&lt;String, Object&gt;&gt;() { @Override public int compare(Map.Entry&lt;String, Object&gt; o1, Map.Entry&lt;String, Object&gt; o2) { return String.valueOf(o1.getValue()).compareTo(String.valueOf(o2.getValue())); } }; //用lambda Comparator&lt;Map.Entry&lt;String,Object&gt;&gt; co1 = (o1, o2) -&gt; String.valueOf(o1.getValue()).compareTo(String.valueOf(o2.getValue())); //Comparator.comparing() Comparator&lt;Map.Entry&lt;String,Object&gt;&gt; co2 = Comparator.comparing(o -&gt; String.valueOf(o.getValue())); //将map转换为map.entrySet() List&lt;Map.Entry&lt;String,Object&gt;&gt; listEntry = new ArrayList&lt;&gt;(map.entrySet()); //调用排序 listEntry.sort(co); // listEntry.sort(co.reversed()); // Collections.sort(listEntry,co); System.out.println(listEntry); }   ]]></content></entry><entry><title>Java枚举使用</title><url>/post/%E7%BC%96%E7%A8%8B/java/java%E6%9E%9A%E4%B8%BE%E4%BD%BF%E7%94%A8/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  实现接口,相当于简单的抽象工厂 接口方法 //接口方法 interface EnumInterface{ void show(); } 枚举 //实现接口并重写方法 enum Enumenum implements EnumInterface{ AAA(1){ @Override public void show() { System.out.println(&#34;AAA&#34;); } }, BBB(2){ @Override public void show() { System.out.println(&#34;BBB&#34;); } } ; private int i; //通过i调用show() static void getEnumbyI(int a){ Arrays.stream(Enumenum.values()).filter(item-&gt;item.getI() == a).findFirst().get().show(); } //构造方法 Enumenum(int i) { this.i = i; } public int getI() { return i; } } 测试 /** * 枚举的使用 */ public class EnumApplication { public static void main(String[] args) { getEnumByI(); } //通过值获取枚举的方法 private static void getEnumByI(){ try { Enumenum.getEnumbyI(1); } catch (NoSuchElementException e) { System.out.println(&#34;枚举中没有此值&#34;); } } }   ]]></content></entry><entry><title>Java模拟鼠标操作</title><url>/post/%E7%BC%96%E7%A8%8B/java/java%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  /** * 定时执行模拟鼠标键盘操作 * Robot中主要的鼠标和键盘控制方法有： * • void keyPress(int keycode) 按下给定的键。 * • void keyRelease(int keycode) 释放给定的键。 * • void mouseMove(int x, int y) 将鼠标指针移动到给定屏幕坐标。 * • void mousePress(int buttons) 按下一个或多个鼠标按钮。 * • void mouseRelease(int buttons) 释放一个或多个鼠标按钮。 * • void mouseWheel(int wheelAmt) 在配有滚轮的鼠标上旋转滚轮。 */ private static void mouse(){ new Thread(()-&gt;{ while (true){ try { Thread.sleep(1000*60); Robot robot = new Robot(); //设置Robot产生一个动作后的休眠时间,否则执行过快 robot.setAutoDelay(1000); //获取屏幕分辨率 Dimension d = Toolkit.getDefaultToolkit().getScreenSize(); System.out.println(d); Rectangle screenRect = new Rectangle(d); //截图 BufferedImage bufferedImage = robot.createScreenCapture(screenRect); //保存截图 File file = new File(&#34;screenRect.png&#34;); ImageIO.write(bufferedImage, &#34;png&#34;, file); //移动鼠标 robot.mouseMove(500, 500); //点击鼠标 //鼠标左键 System.out.println(&#34;单击&#34;); robot.mousePress(InputEvent.BUTTON1_MASK); robot.mouseRelease(InputEvent.BUTTON1_MASK); //鼠标右键 System.out.println(&#34;右击&#34;); robot.mousePress(InputEvent.BUTTON3_MASK); robot.mouseRelease(InputEvent.BUTTON3_MASK); //按下ESC，退出右键状态 System.out.println(&#34;按下ESC&#34;); robot.keyPress(KeyEvent.VK_ESCAPE); robot.keyRelease(KeyEvent.VK_ESCAPE); //滚动鼠标滚轴 System.out.println(&#34;滚轴&#34;); robot.mouseWheel(5); //按下Alt+TAB键 robot.keyPress(KeyEvent.VK_ALT); for(int i=1;i&lt;=2;i++) { robot.keyPress(KeyEvent.VK_TAB); robot.keyRelease(KeyEvent.VK_TAB); } robot.keyRelease(KeyEvent.VK_ALT); } catch (InterruptedException e) { e.printStackTrace(); } catch (AWTException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } }); }   ]]></content></entry><entry><title>Java线程</title><url>/post/%E7%BC%96%E7%A8%8B/java/java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  创建线程的方法 继承Thread类,重写run()方法,调用start()方法开启 实现Runnable,重写run()方法,调用start()方法开启 通过Callable和FutureTask创建线程 通过线程池创建线程 继承Thread类 线程开启后不一定立即执行,由CPU调度执行
public class ThreadRun { public static void main(String[] args) { //开启线程 ThreadDemoOne threadDemoOne = new ThreadDemoOne(); threadDemoOne.start(); for (int i = 0; i &amp;lt; 5000; i++) { System.out.printf(&amp;#34;普通代码: %d%n&amp;#34;, i); } } } /** *	继承Thread类的方法,并重run() **/ class ThreadDemoOne extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 5000; i++) { System.out.println(&amp;#34;线程在这里!!&amp;#34;); } } } 执行结果
线程在这里!! 普通代码: 694 普通代码: 695 线程在这里!! 普通代码: 696 线程在这里!! 实现Runnable public class ThreadDemoTwo { public static void main(String[] args) { //开启线程 Thread thread = new Thread(new ThreadTest()); thread.start(); //普通代码块 for (int i = 0; i &amp;lt; 5000; i++) { System.out.printf(&amp;#34;普通代码: %d%n&amp;#34;, i); } } } /** * 实现Runnable,并重写run() */ class ThreadTest implements Runnable { @Override public void run() { for (int i = 0; i &amp;lt; 5000; i++) { …  ]]></content></entry><entry><title>Java验证码</title><url>/post/%E7%BC%96%E7%A8%8B/java/java%E9%AA%8C%E8%AF%81%E7%A0%81/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  Utility.java 验证码调用工具类 import org.apache.commons.lang3.StringUtils; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import java.math.BigDecimal; import java.text.SimpleDateFormat; import java.util.*; public class Utility { protected final static Log logger = LogFactory.getLog(Utility.class); public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; newArray(int size, Class&amp;lt;T&amp;gt; clazz) { List&amp;lt;T&amp;gt; l = new ArrayList&amp;lt;T&amp;gt;(); for (int i = 0; i &amp;lt; size; i++) { T newInstance; try { newInstance = clazz.newInstance(); } catch (Exception e) { newInstance = null; } l.add(newInstance); } return l; } public static String randomString(int len, int type) { StringBuffer str = new StringBuffer(); // 默认去掉了容易混淆的字符oOLlI，要添加请使用addChars参数 String codestr = &amp;#34;ABCDEFGHJKMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz&amp;#34;; String codeNum = &amp;#34;0123456789&amp;#34;; //	switch (type) { //	case 0: //	codestr = &amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&amp;#34;; //	break; //	case 1: …  ]]></content></entry><entry><title>Jdbc</title><url>/post/%E7%BC%96%E7%A8%8B/java/jdbc/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  JDBC程序 private static void jdbcUtil() throws ClassNotFoundException, SQLException { //1. 加载驱动 Class.forName(&#34;com.mysql.jdbc.Driver&#34;); //2.用户信息和url /** * useUnicode=true 使用unicode编码,支持中文 * characterEncoding=utf8 设置字符集为UTF-8 * useSSL=true 使用SSL安全连接 */ String url = &#34;jdbc:mysql://localhost:3306/lvxiaobin?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&#34;; String username = &#34;lv&#34;; String password = &#34;xiao&#34;; //3.接连成功,获取数据库对象 Connection connection = DriverManager.getConnection(url, username, password); //4.执行sql的对象 Statement statement = connection.createStatement(); //5.执行sql String sql = &#34;select * from user&#34;; //返回的结果集 ResultSet resultSet = statement.executeQuery(sql); while (resultSet.next()) { System.out.println(resultSet.getString(&#34;id&#34;)); } //6.释放连接 resultSet.close(); statement.close(); connection.close(); }   ]]></content></entry><entry><title>springBoot</title><url>/post/%E7%BC%96%E7%A8%8B/java/spring/springboot/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[   小彩蛋：修改springboot启动banner,也就是控制台打印的图像 在resources在创建banner.txt,然后把网上复制的banner粘贴进去
.::::. .::::::::. ::::::::::: &amp;#39;:::::::::::.. :::::::::::::::&amp;#39; &amp;#39;:::::::::::. .::::::::::::::&amp;#39; .:::::::::::... ::::::::::::::&amp;#39;&amp;#39; .:::. &amp;#39;::::::::&amp;#39;&amp;#39;:::: .::::::::. &amp;#39;:::::&amp;#39; &amp;#39;:::: .::::&amp;#39;:::::::. ::::: &amp;#39;::::. .:::::&amp;#39; &amp;#39;:::::::::. ::::: &amp;#39;:::. .:::::&amp;#39; &amp;#39;:::::::::.::::: &amp;#39;::. .::::&amp;#39;&amp;#39; &amp;#39;:::::::::::::: &amp;#39;::. .::&amp;#39;&amp;#39; &amp;#39;:::::::::::: :::... ..:::: &amp;#39;:::::::::&amp;#39; .:&amp;#39; &amp;#39;&amp;#39;&amp;#39;&amp;#39; ..&amp;#39;&amp;#39;&amp;#39;&amp;#39;&amp;#39;:&amp;#39; &amp;#39;:::::.&amp;#39; 1. springboot依赖 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; …  ]]></content></entry><entry><title>springMVC</title><url>/post/%E7%BC%96%E7%A8%8B/java/spring/springmvc/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"> SpringMVC MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。
Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） - 视图代表模型包含的数据的可视化。 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 MVC的优点：
1. 耦合性 低
视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。
2.重用性高
MVC 模式 允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型，它包括任何WEB（HTTP）浏览器或者无线浏览器（wap），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。
3.部署快，生命周期成本低
MVC使开发和维护用户接口的技术含量降低。使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。
4.可维护性高
分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。
MVC的缺点：
1.完全理解MVC比较复杂。
由于MVC模式提出的时间不长，加上同学们的实践经验不足，所以完全理解并掌握MVC不是一个很容易的过程。
2.调试困难。
因为模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难，每个构件在使用之前都需要经过彻底的测试。
3.不适合小型，中等规模的应用程序
在一个中小型的应用程序中，强制性的使用MVC进行开发，往往会花费大量时间，并且不能体现MVC的优势，同时会使开发变得繁琐。
4.增加系统结构和实现的复杂性
对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。
5.视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问
…</content></entry><entry><title>spring定时器依赖注入</title><url>/post/%E7%BC%96%E7%A8%8B/java/spring/spring%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[   工具类 /** * 创建工具类 **/ public class ApplicationContextUtil implements ApplicationContextAware { private static ApplicationContext applicationContext; public static ApplicationContext getApplicationContext() { return applicationContext; } public void setApplicationContext(ApplicationContext applicationContext) { ApplicationContextUtil.applicationContext = applicationContext; } public static Object getBean(String beanName) { return applicationContext.getBean(beanName); } } 配置bean &lt;bean id =&#34;applicationContextUtil&#34; class =&#34;org.sihai.soil.util.ApplicationContextUtil&#34; &gt;&lt;/bean &gt; 获取service realmEbi = (RealmEbi) ApplicationContextUtil.getBean(&#34;realmEbi&#34;); realmEbi.insertHour(RealmApplianceModel.sendData3);   ]]></content></entry><entry><title>spring简介</title><url>/post/%E7%BC%96%E7%A8%8B/java/spring/spring%E7%AE%80%E4%BB%8B/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"><![CDATA[  简介 Spring框架是一个 开放源代码 的 J2EE 应用程序框架，由[Rod Johnson]( https://baike.baidu.com/item/Rod Johnson/1423612)发起，是针对bean的生命周期进行管理的轻量级容器（lightweight container）。 Spring解决了开发者在J2EE开发中遇到的许多常见的问题，提供了功能强大IOC、 AOP 及Web MVC等功能。Spring可以单独应用于构筑应用程序，也可以和Struts、Webwork、Tapestry等众多Web框架组合使用，并且可以与 Swing等 桌面应用程序 AP组合。因此， Spring不仅仅能应用于J2EE应用程序之中，也可以应用于桌面应用程序以及小应用程序之中。Spring框架主要由七部分组成，分别是 Spring Core、 Spring AOP、 Spring ORM、 Spring DAO、Spring Context、 Spring Web和 Spring Web MVC。
Spring Framework 为现代基于 Java 的企业应用程序提供了一个全面的编程和配置模型 - 在任何类型的部署平台上。
Spring 的一个关键元素是应用程序级别的基础设施支持：Spring 专注于企业应用程序的“管道”，以便团队可以专注于应用程序级业务逻辑，而无需与特定部署环境产生不必要的联系。
优点 开源免费的框架(容器) 轻量级、非入侵式的框架 控制反转（IOC），面向切面编程（AOP） 支持事物的处理，对框架整合的支持！ spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架。
导包 maven 搜索spring,导入webmvc包就会把所有的核心包都导进项目中
&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; 模块组成 拓展 基于spring开发
Spring boot
一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置 Spring Cloud
springCloud是基于SpringBoot实现的 常用注解 @Autowired ：通过名字自动装配 @Qualifier： 如果Autowired不能唯一自动装配上属性，则要通过@Qualifier(value = &quot;xxx&quot;) @Nullable ： 字段可以为null @Resource ： 默认先通过名字，如果找不到再通过类型自动装配 @Component ：组件 等价于，说明这个bean被Spring管理了   ]]></content></entry><entry><title>spring要点</title><url>/post/%E7%BC%96%E7%A8%8B/java/spring/spring%E8%A6%81%E7%82%B9/</url><categories><category>编程</category></categories><tags><tag>java</tag></tags><content type="html"> 1. IOC理论推导 1.1. 原来的写法 1.1.1 UserDao接口 public interface UserDao { void getUser(); } 1.1.2 UserDaoImpl实现类 public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(&amp;amp;#34;默认获取用户数据&amp;amp;#34;); } } 1.1.3 UserService业务接口 public interface IUserService { void getUser(); } 1.1.4 UserServiceImpl业务实现类 public class UserServiceImpl implements IUserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 1.1.5 UserTest测试 public class UserTest { public static void main(String[] args) { //用户实际调用的业务层，Dao层不会直接调用 IUserService userService = new UserServiceImpl(); userService.getUser(); } } 缺点： 当Dao层需要增加需求时，service业务层的代码也需要跟着改变，耦合度太高
1.2 更改之后 1.2.1 在业务层使用set方法获取dao实现 public class UserServiceImpl implements IUserService { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 1.2.2 UserTest调用 public class UserTest { public …</content></entry><entry><title>sqlite</title><url>/post/%E7%BC%96%E7%A8%8B/db/nodejs%E8%BF%9E%E6%8E%A5sqlite%E6%95%B0%E6%8D%AE%E5%BA%93/</url><categories><category>编程</category></categories><tags><tag>数据库</tag></tags><content type="html"><![CDATA[  编译nodejs相关模块better-sqlite3 安装 windows-build-tools ， 注意用管理员身份启动终端（如果安装node的时侯已经安装了相关的tools就略过这一步） npm install --global windows-build-tools 这里有个点要注意一下，这个工具分版本 vs2015, vs2017， 默认是2017，如果是需要2015版安装时后面加参数
npm install --global windows-build-tools --vs2015 如果不知道当前需要哪个版本，先默认安装，后面编译出错会报出来
安装 better-sqlite3 npm install better-sqlite3 如果顺利这里就成功了。
这里有情况
node-gyp报错，仔细看一下，如果是visual studio 工具问题，基本上是版本原因，回第一步
如果只是node-gyp错误
npm uninstall node-gyp -g npm install -g node-gyp 然后再执行安装命令，需要注意，少数情况下node版本也会造成编译失败。
启动 electron 并调用 better-sqlite3 const DB = require(&amp;lsquo;better-sqlite3&amp;rsquo;);
这里还有个可能的报错，编译的node版本对不上，需要使用 electron-rebuild
npm install &amp;ndash;save-dev electron-rebuild
./node_modules/.bin/electron-rebuild # 在windows下如果上述命令遇到了问题，尝试这个： .\node_modules\.bin\electron-rebuild.cmd 这个特别慢， 而且到最后我也没成功， 所以用了别的命令
electron-rebuild -f -w better-sqlite3 或者在package.json的scripts中加入并运行这个
&amp;#34;rebuild&amp;#34;: &amp;#34;electron-rebuild -f -w better-sqlite3&amp;#34;, better-sqlite3基础操作： API new Database(path, [options]) 创建一 …  ]]></content></entry><entry><title>达梦数据库</title><url>/post/%E7%BC%96%E7%A8%8B/db/%E8%BE%BE%E6%A2%A6%E6%95%B0%E6%8D%AE%E5%BA%93/</url><categories><category>编程</category></categories><tags><tag>数据库</tag></tags><content type="html"><![CDATA[  达梦数据库
查询模式sql -- 获取当前用户下的所有表 SELECT * FROM user_tables ORDER BY table_name; -- 获取当前用户下的模式名 SELECT distinct object_name FROM all_objects WHERE object_type=&#39;SCH&#39;; -- 获取当前用户下模式（库）的信息 SELECT * FROM dba_segments; -- 获取模式下的表 SELECT table_name FROM dba_tables WHERE owner=&#39;模式（库）名&#39;; 常用函数 wm_concat(column)	分组时,将其他字段用,分割显示   ]]></content></entry></search>