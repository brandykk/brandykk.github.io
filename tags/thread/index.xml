<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Thread on Brandy</title>
    <link>https://brandykk.github.io/tags/thread/</link>
    <description>Recent content in Thread on Brandy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This is a customized copyright.</copyright>
    <lastBuildDate>Mon, 19 Jul 2021 22:04:34 +0800</lastBuildDate>
    <atom:link href="https://brandykk.github.io/tags/thread/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java中的线程</title>
      <link>https://brandykk.github.io/posts/java/java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 19 Jul 2021 22:04:34 +0800</pubDate>
      <guid>https://brandykk.github.io/posts/java/java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</guid>
      <description>创建线程的方法 继承Thread类,重写run()方法,调用start()方法开启 实现Runnable,重写run()方法,调用start()方法开启 通过Callable和FutureTask创建线程 通过线程池创建线程 继承Thread类 线程开启后不一定立即执行,由CPU调度执行&#xA;public class ThreadRun { public static void main(String[] args) { //开启线程 ThreadDemoOne threadDemoOne = new ThreadDemoOne(); threadDemoOne.start(); for (int i = 0; i &amp;lt; 5000; i++) { System.out.printf(&amp;#34;普通代码: %d%n&amp;#34;, i); } } } /** *&#x9;继承Thread类的方法,并重run() **/ class ThreadDemoOne extends Thread { @Override public void run() { for (int i = 0; i &amp;lt; 5000; i++) { System.out.println(&amp;#34;线程在这里!!&amp;#34;); } } } 执行结果&#xA;线程在这里!! 普通代码: 694 普通代码: 695 线程在这里!</description>
    </item>
  </channel>
</rss>
