---
title: "Java面试题"
date: 2021-06-20T16:18:38+08:00
description: "随便记录点面试可能问的东西"
tags: [java]
featured_image: ""
# images is optional, but needed for showing Twitter Card
images: []
categories: 开发
comment : true
---

## Spring

### 1. spring的优良特性

> 1. 非侵入式: 基于spring开发的应用中的对象可以不依赖于spring的API;
> 2. 依赖注入: DI,反转控制(IOC)最经典的实现
> 3. 面向切面:AOP
> 4. 容器:spring是一个容器,因为它包含并且管理应用对象的生命周期
> 5. 组件化: spring实现了使用简单的组件配置组合成一个复杂的应用,在spring中可以使用XML和JAVA注解组合这些对象
> 6. 一站式: 在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方库(实际上spring自身也提供了表述层的springMVC和持久层的springJDBC)

### 2. SpringBean生命周期

> Bean从创建到销毁的整个过程： 分4大步：

- 实例化
  - 通过反射去推断构造函数进行实例化
  - 实例工厂、静态工厂
- 属性赋值
  - 解析自动装配（DI的体现）
  - 循环依赖
- 初始化
  - 调用`XXXAware`回调方法
  - 调用初始化生命周期回调（三种）
  - 如果bean实现AOP,创建动态代理
- 销毁
  - 在spring容器关闭的时候进行调用
  - 调用销毁生命周期回调

### 3. IOC

> 控制反转：当我们创建对象时使用`new`来创建，比如`UserService service = new UserService（）`但是当我们改变创建的对象时需要更改每一个类中的`new Service`
> 
> 所以便引入了IOC，IOC是一种思想，IOC负责创建对象、管理对象（DI：`@Autowired`、set方法、构造器）、装配对象、配置对象，并且管理这些对象的整个生命周期。

**优点：**

- 集中管理对象，方便维护
- 降低偶和度
  - 最小代价和最小侵入性使松散偶和得以实现
  - IOC容器支持加载服务时的饿汉式初始化和懒加载

### 4. Spring事务

**编程式事务：** 通过编程方式在代码中管理事务，有极大的灵活性，但是难维护。

**声明式事务：** 使用注解和XML配置来管理事务，将业务代码和事务管理分离。

**实现方式：**

- 基于接口（不建议，不利于维护）
- 基于XML配置
- 使用注解

### 5. Spring事务隔离

- 脏读：一个事务读取了另一个事务中没有提交的数据
- 不可重复读：同一个事务中多次读取相同的数据时有另一个事务修改了数据，导致在同一个事务中多次读取出来的结果不一样
- 幻读：事务A对表中所有的数据进行修改，同时事务B在此表中添加了一条数据，此时会发生执行事务A的用户发现还有没有修改的数据，就像发生了幻觉一样

>  **隔离级别**

- **DEFAULT**    使用数据库本身使用的隔离级别
- **ORACLE**（读已提交） MySQL（可重复读）
- **READ_UNCOMITTED**    读未提交（脏读）最低的隔离级别，一切皆有可能。
- **READ_COMMITED**    读已提交，ORACLE默认隔离级别，有幻读以及不可重复读风险。
- **REPEATABLE_READ**    可重复读，解决不可重复读的隔离级别，但还是有幻读风险。
- **SERLALIZABLE**    串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了

### 6. AOP

[参考](https://blog.csdn.net/qukaiwei/article/details/50367761)

---

## springMVC

#### 1.什么是MVC？

MVC 是 Model、View 和 Controller 的缩写，分别代表 Web 应用程序中的 3 种职责，MVC是一种软件设计规范。它将业务逻辑、数据、显示分离的方法来组织代码，降低了视图与业务逻辑之间的双向耦合。

    Model(模型)：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。
    View(视图)：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。
    Controller(控制器)：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。

![最典型的MVC模式就是JSP+Servlet+JavaBean的模式](%E9%9D%A2%E8%AF%95%E9%A2%98.assets/20200901164438483.png)

#### 2. 什么是SpringMVC？

    SpringMVC是一个基于MVC模式的Web框架，是Spring框架的一个模块 。
    它以SpringIOC容器为基础，并利用容器的特性来简化它的配置，所以 SpringMVC 和 Spring 可直接整合使用。
    SpringMVC 对 MVC 流程进行了封装，屏蔽掉很多底层代码，让开发者可以更加轻松快捷的完成基于 MVC 模式的 Web 开发。
    总的来说：Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。

#### 3. SpringMVC的特点：

    轻量级，简单易学
    高效 , 基于请求响应的MVC框架
    与Spring兼容性好，无缝结合
    约定优于配置
    功能强大：RESTful、数据验证、格式化、本地化、主题等
    简洁灵活

#### 4. SpringMVC中的核心组件

（1）前端控制器：DispactherServlet
（2）处理器映射器：HandlerMapping
（3）处理器适配器：HandlerAdapter
（4）处理器：Handler，
（5）视图解析器：ViewResolver
（6）视图：View
组件的介绍

    前端控制器：接收请求、响应结果，相当于转发器，它是SpringMVC框架最核心的组件，有了它就能减少其他组件之间的耦合度。（不需要程序员开发）
    处理器映射器：根据配置的映射规则（根据请求的URL），找到对应的处理器。（不需要程序员开发）
    处理器适配器：适配调用具体的处理器，并且执行处理器中处理请求的方法，执行完毕之后返回一个ModelAndView对象。
    处理器：（需要程序员手动开发）。
    视图解析器：会根据传递过来的ModelAndView对象进行视图解析，根据视图解析名解析称真正的视图View。（不需要程序员开发）
    视图：View是一个接口，它的实现类支持不同类型的视图。比如：JSP、freemarker、Thymeleaf等等。

SpringMVC的执行流程

![SpringMVC的执行流程](%E9%9D%A2%E8%AF%95%E9%A2%98.assets/20200902094756141.png)
（1）当用户通过浏览器发起一个HTTP请求，请求直接到前端控制器DispatcherServlet；
（2）前端控制器接收到请求以后调用处理器映射器HandlerMapping，处理器映射器根据请求的URL找到具体的Handler，并将它返回给前端控制器；
（3）前端控制器调用处理器适配器HandlerAdapter去适配调用Handler；
（4）处理器适配器会根据Handler去调用真正的处理器去处理请求，并且处理对应的业务逻辑；
（5）当处理器处理完业务之后，会返回一个ModelAndView对象给处理器适配器，HandlerAdapter再将该对象返回给前端控制器；这里的Model是返回的数据对象，View是逻辑上的View。
（6）前端控制器DispatcherServlet将返回的ModelAndView对象传给视图解析器ViewResolver进行解析，解析完成之后就会返回一个具体的视图View给前端控制器。（ViewResolver根据逻辑的View查找具体的View）
（7）前端控制器DispatcherServlet将具体的视图进行渲染，渲染完成之后响应给用户（浏览器显示)。

#### 5. 关于DispatcherServlet的配置说明

使用SpringMVC时，第一步就是web.xml中配置DispatcherServlet，DispatcherServlet实际上就是一个Servlet，因此我们可以配置多个DispatcherServlet，它是前端控制器，在web.xml文件中配置时，还需要配置拦截匹配的请求，以及Springmvc的配置文件的加载，还有启动顺序的配置，使得该servlet随着Servlet容器的启动而启动，以下就是关于DispatcherServlet的常规配置：

    <!--配置前端控制器-->
        <servlet>
            <servlet-name>DispactherServlet</servlet-name>
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
            <init-param>
                <!--配置加载Springmvc的配置文件-->
                <param-name>contextConfigLocation</param-name>
                <param-value>classpath:springmvc-config.xml</param-value>
            </init-param>
            <!--配置启动顺序，数字越小启动优先级越高-->
            <load-on-startup>1</load-on-startup>
        </servlet>
        <servlet-mapping>
            <servlet-name>DispactherServlet</servlet-name>
            <url-pattern>/</url-pattern>
        </servlet-mapping>

以上指明了配置文件的文件名，不使用默认配置文件名，而使用springmvc-config.xml配置文件。
其中**.xml 这里可以使用多种写法
1、不写,使用默认值:/WEB-INF/-servlet.xml
2、/WEB-INF/classes/springMVC.xml
3、classpath*:springmvc-config.xml
4、多个值用逗号分隔
关于SpringMVC的配置文件以及常用部分注解解释

代码为：

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xmlns:mvc="http://www.springframework.org/schema/mvc"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/mvc
           http://www.springframework.org/schema/mvc/spring-mvc.xsd">
        <!--自动扫描指定的包，下面所有注解类交给IOC容器处理-->
        <context:component-scan base-package="com.oldou.controller"/>
    
        <!--配置注解驱动-->
        <mvc:annotation-driven/>
    
        <!--配置视图解析器-->
        <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
            <!--前缀-->
            <property name="prefix" value="/WEB-INF/jsp/"/>
            <!--后缀-->
            <property name="suffix" value=".jsp"/>
        </bean>
    
         <!--配置对静态资源的访问(方式一) 2选1-->
         <mvc:default-servlet-handler/>      
        <!--配置对静态资源的访问(方式二) 2选1-->
        <mvc:resources mapping="/js/**" location="/WEB-INF/js/"/>
        <mvc:resources mapping="/img/**" location="/WEB-INF/img/"/>
        <mvc:resources mapping="/css/**" location="/WEB-INF/css/"/>
    
        <!--配置拦截器-->
        <mvc:interceptors>
            <mvc:interceptor>
                <!--/** 包括路径及其子路径-->
                <!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截-->
                <!--/admin/** 拦截的是/admin/下的所有-->
                <mvc:mapping path="/**"/>
                <!--bean配置的就是拦截器-->
                <bean class="com.oldou.Interceptor.MyInterceptor"/>
            </mvc:interceptor>
        </mvc:interceptors>
    
    <!--文件上传配置-->
    <bean id="multipartResolver"  class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
       <!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->
       <property name="defaultEncoding" value="utf-8"/>
       <!-- 上传文件大小上限，单位为字节（10485760=10M） -->
       <property name="maxUploadSize" value="10485760"/>
       <property name="maxInMemorySize" value="40960"/>
    </bean>
    
    </beans>

以上配置中，配置了扫描Controller层的注解扫描以及注解的驱动支持，还有视图解析器、静态资源映射器、拦截器等等，里面还可以配置文件的上传等等。

对于<mvc:annotation-driven/>扫描指定的包中的类上的注解，常用的注解如下所示：

- @Controller 声明Controller组件，通常作用在控制层（如 Spring MVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。
- @Service 声明Service组件 @Service(“myMovieLister”) ，通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。
- @Repository 声明Dao组件，将数据访问层（DAO 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。
- @Component 泛指组件, 可以使用此注解描述 Spring 中的 Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。使用时只需将该注解标注在相应类上即可。
- @RequestMapping("/menu") 请求映射，用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
- @Resource 用于注入，( j2ee提供的 ) 默认按名称装配， @Resource(name=“beanName”)
- @Autowired 用于注入，(srping提供的) 默认按类型装配
- @Transactional( rollbackFor={Exception.class}) 事务管理
- @RequestBody：注解实现接收http请求的json数据，将json转换为java对象。
- @ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。
- @Scope(“prototype”) 设定bean的作用域
- @GetMapping：它是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式，只能处理 Get 类型请求。
- @PostMapping： 它是@RequestMapping(method =RequestMethod.POST) 的一个快捷方式，只能处理 Post 类型请求。
- @RequestParam ：将请求参数绑定到控制器的方法参数上
- @Configuration：声明当前类为配置类，相当于 xml 形式的 Spring 配置中的，该注解需要添加到类上。

---

## SpringBoot

### 1. SpringBoot核心注解

- @SpringBootApplication：标识一个`springboot`工程，
  - @SpringBootConfiguration：实际就是`@Configuration`，表示启动类也是一个配置类
  - @EnableAutoConfiguration：向Spring容器中导入了一个Selector,用来加载`ClassPath`下SpringFactories中所定义的自动配置类，将这些自动加载为配置bean
  - @conditional
    - @ConditionalOnBean
    - @ConditionalOnMissingBean
    - @ConditionalOnClass
    - @ConfitionalOnExpression

### **2. SpringBoot启动原理**

- 运行main方法：初始化SpringApplication，从`spring.factories`读取`listener`(监听器)、`ApplicationContextInitializer`（初始化器）
- 运行run方法
- 读取环境变量、配置信息...
- 创建`SpringApplication`上下文：`ServletWebServerApplicationContext`
- 预初始化上下文：读取启动类
- 调用`refresh`加载IOC容器
  - 加载所有的自动配置类
  - 创建（内置）servlet容器
- 在这个过程中`springboot`会调用很多监听器对外进行拓展

### 3.SpringBoot内置Tomcat启动原理

- 当依赖`Spring-boot-starter-web`依赖时会在SpringBoot中添加：`ServletWebServerFactoryAutoConfiguration` servlet容器自动配置类
- 该自动配置类通过`@Import`导入了可用（通过@ConditionalOnClass判断决定使用哪一个）的一个Web容器工厂（默认Tomcat）
- 在内嵌Tomcat类中配置一个`TomcatServletWebServerFactory`的Bean（Web容器工厂）
- 它会在SpringBoot启动时加载IOC容器（refresh）`OnRefersh`创建内嵌的Tomcat并启动

### 4. 自动配置原理

Spring Boot有一个全局配置文件：application.properties或application.yml。

[参考](https://cloud.tencent.com/developer/article/1674602)

总结：

Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，通过@Bean导入到Spring容器中，以Properties结尾命名的类是和配置文件进行绑定的。它能通过这些以Properties结尾命名的类中取得在全局配置文件中配置的属性，我们可以通过修改配置文件对应的属性来修改自动配置的默认值，来完成自定义配置。

---

## 交换两个变量的值

> a=10,b=20;在不使用第三个变量的情况下交换a,b的值

```java
//使用异或运算; 也是最常见的对称加密算法
int a = 10;//原a
int b = 20；
//此时已赋值的a已经包含了原a和原b两个值的内容
a = a ^ b; //已赋值的
//*****对密文使用密钥进行解密获得原文*****
//把原a赋值给b
//把原b当作密钥  用密文a 异或 原b 得到原a值,并赋值给b
b = a ^ b; //已赋值的b(即原a)称为 现b
//把现b(即: 原a)当作密钥    用密文a 异或 现b(即: 原a) 得到原b值,并赋值给a
a = a ^ b;
System.out.println(String.format("a: %d ; b: %d", a, b));//输出a: 20 ; b: 10
```

> 拓展

- 与运算（&）
  
  进行运算的两个数据，按二进制位进行“与”运算。

​    规则：0&0=0;   0&1=0;    1&0=0;     1&1=1;

​    即： 两位同时为“1”，结果才为“1”，否则为0

- 或运算（|）
  
   进行运算的两个数据，按二进制位进行“或”运算。
  
   运算规则：0|0=0；   0|1=1；   1|0=1；    1|1=1；
  
   即 ：参加运算的两个对象只要有一个为1，其值为1。 

- 非运算：~
  
  1取0，0取1 ~1 = 0, ~0 = 1 ~(10001) = 01110

- 异或运算（^）
  
  参加运算的两个数据，按二进制位进行“异或”运算。
  
  运算规则：0^0=0；   0^1=1；   1^0=1；   1^1=0；
  
  即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。

---

## 单例模式

> 简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。
> 
> getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。

### 1. 懒汉式(线程不安全)

```java
public class Singleton {

    private static Singleton singleton;

    //私有化构造函数,使其不能通过new来创建对象
    private Singleton() {
    }

    //通过此方法获取对象
    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }

}
```

### 2. 懒汉式(线程安全)

> 添加了`synchronized`关键字

```java
public class Singleton {

    private static Singleton singleton;

    //私有化构造函数,使其不能通过new来创建对象
    private Singleton() {
    }

    //通过此方法获取对象
    public static synchronized Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }

}
```

### 3. 饿汉式

```java
public class Singleton {
    //直接创建好对象
    private static Singleton singleton = new Singleton();

    //私有化构造函数,使其不能通过new来创建对象
    private Singleton() {
    }

    //通过此方法获取对象
    public static synchronized Singleton getInstance() {
        return singleton;
    }

}
```

### 4. 静态内部类

```java
public class Singleton {
   private static class  SingletonHandler{
       private static final Singleton SINGLETON = new Singleton();
   }
    //私有化构造函数,使其不能通过new来创建对象
    private Singleton() {}
    //通过此方法获取对象
    public static synchronized Singleton getInstance() {
        return SingletonHandler.SINGLETON;
    }
}
```

### 5. 枚举（官方推荐）

```java
public class Singleton {
    //私有化构造函数,使其不能通过new来创建对象
    private Singleton() {}

    //通过此方法获取对象
    public static Singleton getInstance() {
        return SingletonEnum.INSTANCE.getInstance();
    }

    //通过枚举实现单例
    private enum SingletonEnum {
        INSTANCE;
        private Singleton singleton;
        //jvm保证此方法只调用一次
        private SingletonEnum(){
            System.out.println("init");
            singleton = new Singleton();
        }
        public Singleton getInstance(){
            System.out.println("实例化对象");
            return singleton;
        }
    }
}
```

### 6. 双重校验锁

```java
public class Singleton {  
   private volatile static Singleton singleton;  
   private Singleton (){}  
   public static Singleton getSingleton() {  
   if (singleton == null) {  
       synchronized (Singleton.class) {  
       if (singleton == null) {  
           singleton = new Singleton();  
       }  
       }  
   }  
   return singleton;  
   }  
}
```

---

## mybatis

### 1. 一级缓存

1. 一级缓存是默认开启的
2. 底层其实是基于hashmap的本地内存缓存
3. 作用域是session（其实就相当于一个方法）
4. 当session关闭或者刷新的时候缓存清空
5. 不同sqlsession之间缓存互不影响

### 2. 二级缓存

二级缓存默认是不开启的，需要手动开启二级缓存，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。开启二级缓存的条件也是比较简单，通过直接在 MyBatis 配置文件中通过

```xml
<settings>
    <setting name = "cacheEnabled" value = "true" />
</settings>
```

来开启二级缓存，还需要在 Mapper 的xml 配置文件中加入 `<cache> `标签

二级缓存是Mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

### 3. mybatis分页

Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用Mybatis 的分页插件。

mybatis的分页是基于resultSet结果进行分页的,建议直接在sql进行物理层面的分页

---

## mysql

### 1. 库表设计

### 2. mysql数据引擎的区别

***InnoDB***：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要**对事务的完整性要求比较高**（比如银行），**要求实现并发控制**（比如售票），那选择InnoDB有很大的优势。如果需要**频繁的更新、删除**操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 

**特点**

- 支持行锁，采用MVCC来支持高并发，有可能死锁
- 支持事务
- 支持外键
- 支持崩溃后的安全恢复
- 不支持全文索引

***MyISAM***：插入数据快，空间和内存使用比较低。如果表主要是**用于插入新记录和读出记录**，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。

**特点**

- 不支持行锁(MyISAM只有表锁)，读取时对需要读到的所有表加锁，写入时则对表加排他锁；
- 不支持事务
- 不支持外键
- 不支持崩溃后的安全恢复
- 在表有读取查询的同时，支持往表中插入新纪录
- 支持BLOB和TEXT的前500个字符索引，支持全文索引
- 支持延迟更新索引，极大地提升了写入性能
- 对于不会进行修改的表，支持 压缩表 ，极大地减少了磁盘空间的占用

***MEMORY***：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要**很快的读写速度**，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。

### 3. 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。

### 4. 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

### 5. sql优化

> select ... for update语句带索引的话锁行，不带索引的话是锁表

**Sql执行顺序**

- (8) SELECT     
  
  选择字段 

- (9) DISTINCT column,…
  去重

- (6) AGG_FUNC(column or expression),…
  聚合函数

- (1) FROM [left_table]
  选择表

- (3) <join_type> JOIN <right_table>
  链接

- (2) ON <join_condition>
  链接条件

- (4) WHERE <where_condition>
  条件过滤

- (5) GROUP BY <group_by_list>
  分组

- (7) HAVING <having_condition>
  分组过滤

- (10) ORDER BY <order_by_list>
  排序

- (11) LIMIT count OFFSET count;
  分页
1. 查询SQL尽量不要使用select *，而是具体字段

2. 避免在where子句中使用or来连接条件

3. 使用varchar代替char

4. 尽量使用数值替代字符串类型

5. 查询尽量避免返回大量数据

6. 使用explain分析你SQL执行计划

7. 是否使用了索引及其扫描类型
   
   type：
   
   - ALL 全表扫描，没有优化，最慢的方式
   - index 索引全扫描
   - range 索引范围扫描，常用语<，<=，>=，between等操作
   - ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中
   - eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询
   - const 当查询是对主键或者唯一键进行精确查询，系统会把匹配行中的其他列作为常数处理
   - null MySQL不访问任何表或索引，直接返回结果
   - System 表只有一条记录(实际中基本不存在这个情况)
   
   > System > const > eq_ref > ref > range > index > ALL

8. 避免在where子句中使用!=或<>操作符

9. 去重distinct过滤字段要少

10. where中使用默认值代替null

### 4. 事务

- 原子性（Atomicity）：事务包含的所有操作要么都成功，要么都失败。
- 一致性（Consistency）：事务执行之前和执行之后都必须处于一个状态。
- 隔离性（Isolation）：事务和事务之间互不影响。
- 持久性（Durability）：事务一旦被提交，那么对数据库中的数据改变就是永久的。

### 5. 死锁

> 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。 一种情形，此时执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被其他线程占用并堵塞了的资源。例如，如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1，这样两个线程就发生了死锁现象。

**产生死锁的原因主要是：**

（1）系统资源不足。

（2） 进程运行推进的顺序不合适。

（3）资源分配不当等。

如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。

**产生死锁的四个必要条件**：

（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

  这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

**如何将死锁减至最少**

虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。

**下列方法有助于最大限度地降低死锁**：

（1）按同一顺序访问对象。

（2）避免事务中的用户交互。

（3）保持事务简短并在一个批处理中。

（4）使用低隔离级别。

（5）使用绑定连接。

1、**按同一顺序访问对象**

如果所有并发事务按同一顺序访问对象，则发生死锁的可能性会降低。例如，如果两个并发事务获得 Supplier 表上的锁，然后获得 Part 表上的锁，则在其中一个事务完成之前，另一个事务被阻塞在 Supplier 表上。第一个事务提交或回滚后，第二个事务继续进行。不发生死锁。将存储过程用于所有的数据修改可以标准化访问对象的顺序。

2、**避免事务中的用户交互**

避免编写包含用户交互的事务，因为运行没有用户交互的批处理的速度要远远快于用户手动响应查询的速度，例如答复应用程序请求参数的提示。例如，如果事务正在等待用户输入，而用户去吃午餐了或者甚至回家过周末了，则用户将此事务挂起使之不能完成。这样将降低系统的吞吐量，因为事务持有的任何锁只有在事务提交或回滚时才会释放。即使不出现死锁的情况，访问同一资源的其它事务也会被阻塞，等待该事务完成。

3、**保持事务简短并在一个批处理中**

在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁。事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁。

保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁。

4、**使用低隔离级别**

确定事务是否能在更低的隔离级别上运行。执行提交读允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺。

5、**使用绑定连接**

使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。次级连接所获得的任何锁可以象由主连接获得的锁那样持有，反之亦然，因此不会相互阻塞。

6、**用存储过程查出引起死锁的进程和SQL语句**

假如发生了死锁，我们怎么去检测具体发生死锁的是哪条SQL语句或存储过程？此时我们可以使用以下存储过程来检测，就可以查出引起死锁的进程和SQL语句。

### 6. 索引

**优点：**

- 大大加快数据检索的速度。
- 将随机I/O变成顺序I/O(因为B+树的叶子节点是连接在一起的)
- 加速表与表之间的连接

**缺点：**

- 从空间角度考虑，建立索引需要占用物理空间
- 从时间角度 考虑，创建和维护索引都需要花费时间，例如对数据进行增删改的时候都需要维护索引。

**索引数据结构：**

> 索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。

​        在B+树中，所有的记录节点都是按照键值大小的顺序放在叶子节点上，因为B+树具有有序性，并且所有的数据都存放在叶子节点，所以查找的效率非常高，并且支持排序和范围查找。

​        B+树的索引又可以分为主索引和辅助索引。其中主索引为聚簇索引，辅助索引为非聚簇索引。聚簇索引是以主键作为B+  树索引的键值所构成的B+树索引，聚簇索引的叶子节点存储着完整的数据记录；非聚簇索引是以非主键的列作为B+树索引的键值所构成的。

​        B+树索引，非聚簇索引的叶子节点存储着主键值。所以使用非聚簇索引进行查询时，会先找到主键值，然后到根据聚簇索引找到主键对应的数据域。

**Hash索引和B+树的区别？**

因为两者数据结构上的差异导致它们的使用场景也不同，哈希索引一般多用于精确的等值查找，B+索引则多用于除了精确的等值查找外的其他查找。在大多数情况下，会选择使用B+树索引。

- 哈希索引不支持排序，因为哈希表是无序的。

- 哈希索引不支持范围查找。

- 哈希索引不支持模糊查询及多列索引的最左前缀匹配。

- 因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点
  
  **索引的类型有哪些?**

MySQL主要的索引类型主要有FULLTEXT，HASH，BTREE，RTREE。

- FULLTEXT
  FULLTEXT即全文索引，MyISAM存储引擎和InnoDB存储引擎在MySQL5.6.4以上版本支持全文索引，一般用于查找文本中的关键字，而不是直接比较是否相等，多在CHAR，VARCHAR，TAXT等数据类型上创建全文索引。全文索引主要是用来解决WHERE name LIKE "%zhang%"等针对文本的模糊查询效率低的问题。
- HASH
  HASH即哈希索引，哈希索引多用于等值查询，时间复杂夫为o(1)，效率非常高，但不支持排序、范围查询及模糊查询等。
- BTREE
  BTREE即B+树索引，INnoDB存储引擎默认的索引，支持排序、分组、范围查询、模糊查询等，并且性能稳定。
- RTREE
  RTREE即空间数据索引，多用于地理数据的存储，相比于其他索引，空间数据索引的优势在于范围查找

**索引的种类有哪些？**

- 主键索引：数据列不允许重复，不能为NULL，一个表只能有一个主键索引
- 组合索引：由多个列值组成的索引。
- 唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。
- 全文索引：对文本的内容进行搜索。
- 普通索引：基本的索引类型，可以为NULL

### 7. 索引失效的几种情况（MySQL）

- 前导模糊查询不能利用索引(like '%XX'或者like '%XX%')
- 如果是组合索引的话，如果不按照索引的顺序进行查找，比如直接使用第三个位置上的索引而忽略第一二个位置上的索引时，则会进行全表查询
- 条件中有or
- 索引无法存储null值，所以where的判断条件如果对字段进行了null值判断，将导致数据库放弃索引而进行全表查询
- 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
- in 和 not in 也要慎用，否则会导致全表扫描
- 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。
- 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

---

## java集合体系

[参考](https://www.cnblogs.com/java1024/p/13462044.html)

---

## 多线程

[参考](https://cloud.tencent.com/developer/article/1818432)

### 1. **Java 实现线程有哪几种方式？**

- 继承 Thread 类实现多线程
- 实现 Runnable 接口方式实现多线程
- 使用 ExecutorService、Callable、Future 实现有返回结果的多线程
- 通过线程池创建线程

### **2. 一个线程的生命周期有哪几种状态？它们之间如何流转的？**

![img](%E9%9D%A2%E8%AF%95%E9%A2%98.assets/9f0d10392abeb057a86fb0e1659e205f.png)

- 初始状态 : 线程对象创建完成 就是new创建了一个线程对象
- 就绪状态 : 线程可以被执行 就是调用了start()方法后的状态
- 运行状态 : 线程正在运行中 就是就绪状态的线程获取了CPU执行权执行线程
- 阻塞状态 : 线程休眠 就是调用了Thread.sleep()方法使线程进入休眠
- 等待队列 : 线程陷入无限的等待中 就是线程执行wait()方法,进入这个状态后
- 锁池状态 : 线程被唤醒,但没有获取到锁 同步锁被别的线程占用，则该线程放入“锁池”中,进入锁池状态
- 死亡状态 : 线程执行完毕或被关闭 就是run()方法执行完毕后,线程就进入死亡状态

### 3. 线程池的作用是什么，常见的参数有哪些？

**线程池的作用** ：

第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

第三：提高线程的可管理性。

**常见参数：**

- corePoolSize：核心线程数
- queueCapacity：任务队列容量(阻塞队列)
- maxPoolSize：最大线程数
- keepAliveTime：线程空闲时间
- allowCoreThreadTimeout：允许核心线程超时

---

## redis

### 1. redis单线程为什么还快

> Redis基于Reactor（响应式）模式开发了网络时间处理器。这个处理器叫文件事件处理器，而这个文件事件处理器是单线程的，所以redis才叫单线程的模型。

**单线程快的原因：**

- 纯内存操作
- 核心是基于非阻塞的IO多路复用机制
- 单线程反而避免了多线程的频繁上下文切换带来的性能问题

### 2. redis删除机制

- **定时删除**
  
  创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。
  
    当前时间和expires中对过期时间一致时，定时器触发删除。

- #### 惰性删除
  
  数据到达过期时间，不做处理，等下次访问该数据等时候执行删除。
  
    在获取数据时，内部会调用expirelfNeeded()方法，来确定数据是否到期。
  
        未到期，返回数据。
        到期，删除，返回不存在。
  
  优点：节约cpu性能，到了必须删除的时候才执行删除。
  
  缺点：内存压力较大，会出现长期占用内存的数据。

- #### 定期删除
  
  Redis的存储空间中，每个db都有一个expires。
1. Redis服务器启动初始化的时候，读区配置中的server.hz，默认为10。代表每秒执行10次serverCron()操作。

2. 在serverCron()中会调用databasesCron()来轮询每一个db（即循环expire[*]）。*

3. 在databasesCron()中会调用activeExpireCycle()方法，对每一个expire[*]进行检测，每次执行的时长伟250ms/server.hz。

4. 对某个expire[*]检测时，随机挑选W个key进行检测。如果key超时，即删除。*

5. 如果第四步中，删除的key的数量大于W*25%，则继续在此expire[*]上检测执行。

6. 如果第四步中删除的key的数量小于等于W*25%，则检测下一个expire[*]。（从0-15循环，Redis默认为16个DB）
   
    其中W值，可以在配置文件中配置，对应的属性为ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP；
   
     在第四步中的activeExpireCycle()方法执行检测的时候，因为时间长度时固定的，下一次activeExpireCycle()方法执行为了接着上一次中断的位置执行，用参数current_db来记录当前检测的expire。
   
    **特点**：对cpu的使用有峰值，也有一定的自定义空间。删除过程中，内存的压力也不是很大。
   **Redis采用的策略**：惰性删除+定期删除。

### 3. redis持久化机制

>  RDB: (Redis DataBases) 将某一时刻的内存快照,以二进制的方式写入磁盘

**手动触发**

- save命令:  使redis处于阻塞状态,直到RDB持久化完成后才能相应客户端的其他命令,慎用
- bgsave命令:  fork(分支)出一个子进程执行持久化, 主进程只在fork过程中有短暂阻塞,子进程创建成功后就可以响应客户端请求了。

**优点**：

1. 整个Redis数据库将只包含一个文件dump.rdb,方便持久化
2. 容灾性好，方便备份。
3. 性能最大化，使用子进程完成写操作，主进程处理命令，IO最大化。

**缺点：**

1. 数据安全性低，RDB是间隔一段时间进行持久化，容易造成数据丢失。
2. 通过子进行完成数据持久化时，如果数据过大，会造成服务器短暂停止服务，占用CPU.

>  AOF：Append Only File  以日至形式记录服务器所处理的每个写、删除操作，查询不会记录，以文本方式记录，可以发开文件看到详细操作记录。

 **优点：**

1. 数据安全
2. 通过append模式写文件，即使中途服务宕机，也不会破坏已经保存的内容
3. AOF机制的rewrite模式，定期对AOF文件进行重写，以达到压缩目的。

**缺点：**

1. AOF文件比RDB文件大,恢复速度慢。
2. 数据集大时比RDB启动效率低。
3. 运行效率没有RDB高

### 4. 缓存穿透、击穿、雪崩

- **缓存穿透**： 某一时刻访问redis的大量key在缓存和数据库中都不存在（比如伪造key），给数据库造成压力。
  
  **解决方案**：
  
  - 使用布隆过滤器，在缓存之前加一层过滤器拦截不存在key
  - 接口增加校验：比如用户鉴权校验，id做基础校验
  - 数据不存在时将value设为null，设置一个30秒的有效时间，防止同一个id重复恶意攻击

- **缓存击穿**：缓存中没有，但数据库中有（一般是缓存时间到期），导致大量请求直接访问数据库。
  
  **解决方案**：
  
  - 热点key不设置过期时间
  - 互斥锁

- **缓存雪崩**：某一时刻大量热点数据过期，导致大量请求直接访问数据库造成数据库压力大。
  
  **解决方案**：
  
  - 过期时间增加一点随机值，避免大量数据同时失效也可以搭建高可用的redis集群。
  - 给缓存数据增加缓存标记，如果标记失效则刷新缓存
  - 缓存预热：在服务启动前先把热点数据加载进缓存
  - 互斥锁：在查询缓存时发现数据失效，在要查询数据库时添加锁，等查完数据库时再把锁放开

## 深拷贝和浅拷贝

> **浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。**

​    [参考](https://blog.csdn.net/Revivedsun/article/details/108219274)

## 序列化和反序列化

> Java序列化就是指把Java对象转换为字节序列的过程
> 
> Java反序列化就是指把字节序列恢复为Java对象的过程

举例：

**序列化：** 使用outputStream将一个对象中的数据写入流并生成文件

**反序列化：** 使用inputStream将文件中的数据读出来放进对象
